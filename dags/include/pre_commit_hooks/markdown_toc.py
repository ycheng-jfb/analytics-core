import sys


def wrap_toc(toc_content, start_token, end_token):
    out = f"""
{start_token} TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN markdown_toc.py TO UPDATE -->
**Table of Contents**
{toc_content}
{end_token} TOC please keep comment here to allow auto update -->"""
    return out


def anchor_name(section_name, section_count):
    repl_map = str.maketrans(
        {" ": "-", "`": "", ".": "_", "/": "_", "&": "_", "~": "-", "?": ""}
    )
    if section_count > 1:
        suffix = f"_{section_count}"
    else:
        suffix = ""

    return section_name.translate(repl_map).lower() + suffix


def anchor_tag(section_name, section_count):
    return f'{autogen_token}<a name="{anchor_name(section_name, section_count)}"></a>'


def toc_element(header_type, section_name, section_count):
    prefix = "- " if header_type == "h1" else "  - "
    return prefix + f"[{section_name}](#{anchor_name(section_name, section_count)})"


def parse_section_name(line, htype):
    if htype == "h1":
        section = line[2:]
    if htype == "h2":
        section = line[3:]
    return section.strip().replace("`", "")


class SectionCounter:
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.section_counter = {}

    def increment_section_count(self, section):
        if section in self.section_counter:
            count = self.section_counter[section]
            self.section_counter[section] = 1 + count
        else:
            self.section_counter[section] = 1

    def get_section_count(self, section):
        return self.section_counter[section]


start_toc_token = "<!-- START autogenerated"
end_toc_token = "<!-- END autogenerated"
autogen_token = "<!-- autogenerated -->"


def process_content(content):
    section_counter = SectionCounter()

    toc = []
    out_content = []

    is_in_toc = False
    is_in_code_block = False
    for idx, line in enumerate(content.splitlines()):
        if line[0:3] in ("---", "==="):
            raise Exception(
                f"bad header found on line {idx}; use '# ', '## ' to denote headings."
            )
        if line[0 : len(start_toc_token)] == start_toc_token:
            is_in_toc = True
        if line[0 : len(end_toc_token)] == end_toc_token:
            is_in_toc = False
            continue
        if is_in_toc:
            continue
        if line[0:3] == "```":
            is_in_code_block = not is_in_code_block
            out_content.append(line)
            continue
        if line[0:3] == "```":
            is_in_code_block = not is_in_code_block
            out_content.append(line)
            continue
        if is_in_code_block:
            out_content.append(line)
            continue
        if line[0 : len(autogen_token)] == autogen_token:
            continue
        if line[0:2] == "# ":
            section = parse_section_name(line=line, htype="h1")
            section_counter.increment_section_count(section)
            count = section_counter.get_section_count(section)
            out_content.append(anchor_tag(section_name=section, section_count=count))
            toc.append(
                toc_element(section_name=section, header_type="h1", section_count=count)
            )
        if line[0:3] == "## ":
            section = parse_section_name(line=line, htype="h2")
            section_counter.increment_section_count(section)
            count = section_counter.get_section_count(section)
            out_content.append(anchor_tag(section_name=section, section_count=count))
            toc.append(
                toc_element(section_name=section, header_type="h2", section_count=count)
            )
        out_content.append(line)

    new_toc = wrap_toc(
        toc_content="\n".join(toc), start_token=start_toc_token, end_token=end_toc_token
    )
    new_file_content = new_toc + "\n".join(out_content) + "\n"
    return new_file_content


def process_file(filename):
    with open(filename, "rt") as f:
        content = f.read()

    new_content = process_content(content)
    with open(filename, "wb") as f:
        f.write(new_content.encode("utf-8"))


if __name__ == "__main__":
    filenames = sys.argv[1:]
    filename = None
    try:
        for filename in filenames:
            process_file(filename)
    except Exception as e:
        raise Exception(f"failure in file {filename}; original exception: {e.args}")
